<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Blaze.ByteString.Builder</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><script src="haddock-util.js" type="text/javascript"></script><script type="text/javascript">//<![CDATA[
window.onload = function () {pageLoad();setSynopsis("mini_Blaze-ByteString-Builder.html");};
//]]>
</script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">blaze-builder-0.3.3.4: Efficient buffered output.</p></div><div id="content"><div id="module-header"><table class="info"><tr><th>Copyright</th><td>(c) 2010 Jasper Van der Jeugt &amp; Simon Meier</td></tr><tr><th>License</th><td>BSD3-style (see LICENSE)</td></tr><tr><th>Maintainer</th><td>Simon Meier &lt;iridcode@gmail.com&gt;</td></tr><tr><th>Stability</th><td>experimental</td></tr><tr><th>Portability</th><td>tested on GHC only</td></tr><tr><th>Safe Haskell</th><td>None</td></tr><tr><th>Language</th><td>Haskell98</td></tr></table><p class="caption">Blaze.ByteString.Builder</p></div><div id="table-of-contents"><p class="caption">Contents</p><ul><li><a href="#g:1">The <code>Builder</code> type</a></li><li><a href="#g:2">Creating builders</a></li><li><a href="#g:3">Executing builders</a></li><li><a href="#g:4"><code>Write</code>s</a><ul><li><a href="#g:5">Writing <code>Storable</code>s</a></li></ul></li></ul></div><div id="description"><p class="caption">Description</p><div class="doc"><p><a href="Blaze-ByteString-Builder.html">Blaze.ByteString.Builder</a> is the main module, which you should import as a user
 of the <code>blaze-builder</code> library.</p><pre>import Blaze.ByteString.Builder</pre><p>It provides you with a type <code><a href="Blaze-ByteString-Builder.html#t:Builder">Builder</a></code> that allows to efficiently construct
 lazy bytestrings with a large average chunk size.</p><p>Intuitively, a <code><a href="Blaze-ByteString-Builder.html#t:Builder">Builder</a></code> denotes the construction of a part of a lazy
 bytestring. Builders can either be created using one of the primitive
 combinators in <a href="Blaze-ByteString-Builder-Write.html">Blaze.ByteString.Builder.Write</a> or by using one of the predefined
 combinators for standard Haskell values (see the exposed modules of this
 package).  Concatenation of builders is done using <code>mappend</code> from the
 <code>Monoid</code> typeclass.</p><p>Here is a small example that serializes a list of strings using the UTF-8
 encoding.</p><pre> import <a href="Blaze-ByteString-Builder-Char-Utf8.html">Blaze.ByteString.Builder.Char.Utf8</a></pre><pre>strings :: [String]
strings = replicate 10000 &quot;Hello there!&quot;</pre><p>The function <code><code>fromString</code></code> creates a <code><a href="Blaze-ByteString-Builder.html#t:Builder">Builder</a></code> denoting the UTF-8 encoded
 argument. Hence, UTF-8 encoding and concatenating all <code>strings</code> can be done
 follows.</p><pre>concatenation :: Builder
concatenation = mconcat $ map fromString strings</pre><p>The function <code><a href="Blaze-ByteString-Builder.html#v:toLazyByteString">toLazyByteString</a></code>  can be used to execute a <code><a href="Blaze-ByteString-Builder.html#t:Builder">Builder</a></code> and
 obtain the resulting lazy bytestring.</p><pre>result :: L.ByteString
result = toLazyByteString concatenation</pre><p>The <code>result</code> is a lazy bytestring containing 10000 repetitions of the string
 <code>&quot;Hello there!&quot;</code> encoded using UTF-8. The corresponding 120000 bytes are
 distributed among three chunks of 32kb and a last chunk of 6kb.</p><p><em>A note on history.</em> This serialization library was inspired by the
 <code>Data.Binary.Builder</code> module provided by the <code>binary</code> package. It was
 originally developed with the specific needs of the <code>blaze-html</code> package in
 mind. Since then it has been restructured to serve as a drop-in replacement
 for <code>Data.Binary.Builder</code>, which it improves upon both in speed as well as
 expressivity.</p></div></div><div id="synopsis"><p id="control.syn" class="caption expander" onclick="toggleSection('syn')">Synopsis</p><ul id="section.syn" class="hide" onclick="toggleSection('syn')"><li class="src short"><span class="keyword">data</span> <a href="#t:Builder">Builder</a></li><li class="src short">module <a href="Blaze-ByteString-Builder-Int.html">Blaze.ByteString.Builder.Int</a></li><li class="src short">module <a href="Blaze-ByteString-Builder-Word.html">Blaze.ByteString.Builder.Word</a></li><li class="src short">module <a href="Blaze-ByteString-Builder-ByteString.html">Blaze.ByteString.Builder.ByteString</a></li><li class="src short"><a href="#v:flush">flush</a> :: <a href="Blaze-ByteString-Builder.html#t:Builder">Builder</a></li><li class="src short"><a href="#v:toLazyByteString">toLazyByteString</a> :: <a href="Blaze-ByteString-Builder.html#t:Builder">Builder</a> -&gt; <a href="file:///Users/mathiashorrigan/Documents/edx/FP101x_introFunctionalProgramming/present/.cabal-sandbox/share/doc/x86_64-osx-ghc-7.8.3/bytestring-0.10.2.0/html/Data-ByteString-Lazy.html#t:ByteString">ByteString</a></li><li class="src short"><a href="#v:toLazyByteStringWith">toLazyByteStringWith</a> :: <a href="file:///usr/local/Cellar/ghc/7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Int.html#t:Int">Int</a> -&gt; <a href="file:///usr/local/Cellar/ghc/7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Int.html#t:Int">Int</a> -&gt; <a href="file:///usr/local/Cellar/ghc/7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Int.html#t:Int">Int</a> -&gt; <a href="Blaze-ByteString-Builder.html#t:Builder">Builder</a> -&gt; <a href="file:///Users/mathiashorrigan/Documents/edx/FP101x_introFunctionalProgramming/present/.cabal-sandbox/share/doc/x86_64-osx-ghc-7.8.3/bytestring-0.10.2.0/html/Data-ByteString-Lazy.html#t:ByteString">ByteString</a> -&gt; <a href="file:///Users/mathiashorrigan/Documents/edx/FP101x_introFunctionalProgramming/present/.cabal-sandbox/share/doc/x86_64-osx-ghc-7.8.3/bytestring-0.10.2.0/html/Data-ByteString-Lazy.html#t:ByteString">ByteString</a></li><li class="src short"><a href="#v:toByteString">toByteString</a> :: <a href="Blaze-ByteString-Builder.html#t:Builder">Builder</a> -&gt; <a href="file:///Users/mathiashorrigan/Documents/edx/FP101x_introFunctionalProgramming/present/.cabal-sandbox/share/doc/x86_64-osx-ghc-7.8.3/bytestring-0.10.2.0/html/Data-ByteString.html#t:ByteString">ByteString</a></li><li class="src short"><a href="#v:toByteStringIO">toByteStringIO</a> :: (<a href="file:///Users/mathiashorrigan/Documents/edx/FP101x_introFunctionalProgramming/present/.cabal-sandbox/share/doc/x86_64-osx-ghc-7.8.3/bytestring-0.10.2.0/html/Data-ByteString.html#t:ByteString">ByteString</a> -&gt; <a href="file:///usr/local/Cellar/ghc/7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/System-IO.html#t:IO">IO</a> ()) -&gt; <a href="Blaze-ByteString-Builder.html#t:Builder">Builder</a> -&gt; <a href="file:///usr/local/Cellar/ghc/7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/System-IO.html#t:IO">IO</a> ()</li><li class="src short"><a href="#v:toByteStringIOWith">toByteStringIOWith</a> :: <a href="file:///usr/local/Cellar/ghc/7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Int.html#t:Int">Int</a> -&gt; (<a href="file:///Users/mathiashorrigan/Documents/edx/FP101x_introFunctionalProgramming/present/.cabal-sandbox/share/doc/x86_64-osx-ghc-7.8.3/bytestring-0.10.2.0/html/Data-ByteString.html#t:ByteString">ByteString</a> -&gt; <a href="file:///usr/local/Cellar/ghc/7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/System-IO.html#t:IO">IO</a> ()) -&gt; <a href="Blaze-ByteString-Builder.html#t:Builder">Builder</a> -&gt; <a href="file:///usr/local/Cellar/ghc/7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/System-IO.html#t:IO">IO</a> ()</li><li class="src short"><span class="keyword">data</span> <a href="#t:Write">Write</a></li><li class="src short"><a href="#v:fromWrite">fromWrite</a> :: <a href="Blaze-ByteString-Builder.html#t:Write">Write</a> -&gt; <a href="Blaze-ByteString-Builder.html#t:Builder">Builder</a></li><li class="src short"><a href="#v:fromWriteSingleton">fromWriteSingleton</a> ::  (a -&gt; <a href="Blaze-ByteString-Builder.html#t:Write">Write</a>) -&gt; a -&gt; <a href="Blaze-ByteString-Builder.html#t:Builder">Builder</a></li><li class="src short"><a href="#v:fromWriteList">fromWriteList</a> ::  (a -&gt; <a href="Blaze-ByteString-Builder.html#t:Write">Write</a>) -&gt; [a] -&gt; <a href="Blaze-ByteString-Builder.html#t:Builder">Builder</a></li><li class="src short"><a href="#v:writeToByteString">writeToByteString</a> :: <a href="Blaze-ByteString-Builder.html#t:Write">Write</a> -&gt; <a href="file:///Users/mathiashorrigan/Documents/edx/FP101x_introFunctionalProgramming/present/.cabal-sandbox/share/doc/x86_64-osx-ghc-7.8.3/bytestring-0.10.2.0/html/Data-ByteString.html#t:ByteString">ByteString</a></li><li class="src short"><a href="#v:writeStorable">writeStorable</a> :: <a href="file:///usr/local/Cellar/ghc/7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Foreign-Storable.html#t:Storable">Storable</a> a =&gt; a -&gt; <a href="Blaze-ByteString-Builder.html#t:Write">Write</a></li><li class="src short"><a href="#v:fromStorable">fromStorable</a> :: <a href="file:///usr/local/Cellar/ghc/7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Foreign-Storable.html#t:Storable">Storable</a> a =&gt; a -&gt; <a href="Blaze-ByteString-Builder.html#t:Builder">Builder</a></li><li class="src short"><a href="#v:fromStorables">fromStorables</a> :: <a href="file:///usr/local/Cellar/ghc/7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Foreign-Storable.html#t:Storable">Storable</a> a =&gt; [a] -&gt; <a href="Blaze-ByteString-Builder.html#t:Builder">Builder</a></li></ul></div><div id="interface"><h1 id="g:1">The <code><a href="Blaze-ByteString-Builder.html#t:Builder">Builder</a></code> type</h1><div class="top"><p class="src"><span class="keyword">data</span> <a name="t:Builder" class="def">Builder</a></p><div class="subs instances"><p id="control.i:Builder" class="caption collapser" onclick="toggleSection('i:Builder')">Instances</p><div id="section.i:Builder" class="show"><table><tr><td class="src"><a href="file:///usr/local/Cellar/ghc/7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Monoid.html#t:Monoid">Monoid</a> <a href="Blaze-ByteString-Builder.html#t:Builder">Builder</a></td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><h1 id="g:2">Creating builders</h1><div class="top"><p class="src">module <a href="Blaze-ByteString-Builder-Int.html">Blaze.ByteString.Builder.Int</a></p></div><div class="top"><p class="src">module <a href="Blaze-ByteString-Builder-Word.html">Blaze.ByteString.Builder.Word</a></p></div><div class="top"><p class="src">module <a href="Blaze-ByteString-Builder-ByteString.html">Blaze.ByteString.Builder.ByteString</a></p></div><div class="top"><p class="src"><a name="v:flush" class="def">flush</a> :: <a href="Blaze-ByteString-Builder.html#t:Builder">Builder</a></p><div class="doc"><p>Output all data written in the current buffer and start a new chunk.</p><p>The use of this function depends on how the resulting bytestrings are
 consumed. <code><a href="Blaze-ByteString-Builder.html#v:flush">flush</a></code> is possibly not very useful in non-interactive scenarios.
 However, it is kept for compatibility with the builder provided by
 Data.Binary.Builder.</p><p>When using <code><a href="Blaze-ByteString-Builder.html#v:toLazyByteString">toLazyByteString</a></code> to extract a lazy <code><a href="file:///Users/mathiashorrigan/Documents/edx/FP101x_introFunctionalProgramming/present/.cabal-sandbox/share/doc/x86_64-osx-ghc-7.8.3/bytestring-0.10.2.0/html/Data-ByteString-Lazy.html#t:ByteString">ByteString</a></code> from a
 <code><a href="Blaze-ByteString-Builder.html#t:Builder">Builder</a></code>, this means that a new chunk will be started in the resulting lazy
 <code><a href="file:///Users/mathiashorrigan/Documents/edx/FP101x_introFunctionalProgramming/present/.cabal-sandbox/share/doc/x86_64-osx-ghc-7.8.3/bytestring-0.10.2.0/html/Data-ByteString-Lazy.html#t:ByteString">ByteString</a></code>. The remaining part of the buffer is spilled, if the
 reamining free space is smaller than the minimal desired buffer size.</p></div></div><h1 id="g:3">Executing builders</h1><div class="top"><p class="src"><a name="v:toLazyByteString" class="def">toLazyByteString</a> :: <a href="Blaze-ByteString-Builder.html#t:Builder">Builder</a> -&gt; <a href="file:///Users/mathiashorrigan/Documents/edx/FP101x_introFunctionalProgramming/present/.cabal-sandbox/share/doc/x86_64-osx-ghc-7.8.3/bytestring-0.10.2.0/html/Data-ByteString-Lazy.html#t:ByteString">ByteString</a></p><div class="doc"><p>Extract the lazy <code><a href="file:///Users/mathiashorrigan/Documents/edx/FP101x_introFunctionalProgramming/present/.cabal-sandbox/share/doc/x86_64-osx-ghc-7.8.3/bytestring-0.10.2.0/html/Data-ByteString-Lazy.html#t:ByteString">ByteString</a></code> from the builder by running it with default
 buffer sizes. Use this function, if you do not have any special
 considerations with respect to buffer sizes.</p><pre> <code><a href="Blaze-ByteString-Builder.html#v:toLazyByteString">toLazyByteString</a></code> b = <code><a href="Blaze-ByteString-Builder.html#v:toLazyByteStringWith">toLazyByteStringWith</a></code> <code><a href="Blaze-ByteString-Builder-Internal.html#v:defaultBufferSize">defaultBufferSize</a></code> <code><a href="Blaze-ByteString-Builder-Internal.html#v:defaultMinimalBufferSize">defaultMinimalBufferSize</a></code> <code><a href="Blaze-ByteString-Builder-Internal.html#v:defaultFirstBufferSize">defaultFirstBufferSize</a></code> b L.empty</pre><p>Note that <code><code><a href="Blaze-ByteString-Builder.html#v:toLazyByteString">toLazyByteString</a></code></code> is a <code>Monoid</code> homomorphism.</p><pre>toLazyByteString mempty          == mempty
toLazyByteString (x `mappend` y) == toLazyByteString x `mappend` toLazyByteString y</pre><p>However, in the second equation, the left-hand-side is generally faster to
 execute.</p></div></div><div class="top"><p class="src"><a name="v:toLazyByteStringWith" class="def">toLazyByteStringWith</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="file:///usr/local/Cellar/ghc/7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Int.html#t:Int">Int</a></td><td class="doc"><p>Buffer size (upper-bounds the resulting chunk size).</p></td></tr><tr><td class="src">-&gt; <a href="file:///usr/local/Cellar/ghc/7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Int.html#t:Int">Int</a></td><td class="doc"><p>Minimal free buffer space for continuing filling
 the same buffer after a <code><a href="Blaze-ByteString-Builder.html#v:flush">flush</a></code> or a direct bytestring
 insertion. This corresponds to the minimal desired
 chunk size.</p></td></tr><tr><td class="src">-&gt; <a href="file:///usr/local/Cellar/ghc/7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Int.html#t:Int">Int</a></td><td class="doc"><p>Size of the first buffer to be used and copied for
 larger resulting sequences</p></td></tr><tr><td class="src">-&gt; <a href="Blaze-ByteString-Builder.html#t:Builder">Builder</a></td><td class="doc"><p>Builder to run.</p></td></tr><tr><td class="src">-&gt; <a href="file:///Users/mathiashorrigan/Documents/edx/FP101x_introFunctionalProgramming/present/.cabal-sandbox/share/doc/x86_64-osx-ghc-7.8.3/bytestring-0.10.2.0/html/Data-ByteString-Lazy.html#t:ByteString">ByteString</a></td><td class="doc"><p>Lazy bytestring to output after the builder is
 finished.</p></td></tr><tr><td class="src">-&gt; <a href="file:///Users/mathiashorrigan/Documents/edx/FP101x_introFunctionalProgramming/present/.cabal-sandbox/share/doc/x86_64-osx-ghc-7.8.3/bytestring-0.10.2.0/html/Data-ByteString-Lazy.html#t:ByteString">ByteString</a></td><td class="doc"><p>Resulting lazy bytestring</p></td></tr></table></div><div class="doc"><p>Run a <code><a href="Blaze-ByteString-Builder.html#t:Builder">Builder</a></code> with the given buffer sizes.</p><p>Use this function for integrating the <code><a href="Blaze-ByteString-Builder.html#t:Builder">Builder</a></code> type with other libraries
 that generate lazy bytestrings.</p><p>Note that the builders should guarantee that on average the desired chunk
 size is attained. Builders may decide to start a new buffer and not
 completely fill the existing buffer, if this is faster. However, they should
 not spill too much of the buffer, if they cannot compensate for it.</p><p>A call <code>toLazyByteStringWith bufSize minBufSize firstBufSize</code> will generate
 a lazy bytestring according to the following strategy. First, we allocate
 a buffer of size <code>firstBufSize</code> and start filling it. If it overflows, we
 allocate a buffer of size <code>minBufSize</code> and copy the first buffer to it in
 order to avoid generating a too small chunk. Finally, every next buffer will
 be of size <code>bufSize</code>. This, slow startup strategy is required to achieve
 good speed for short (&lt;200 bytes) resulting bytestrings, as for them the
 allocation cost is of a large buffer cannot be compensated. Moreover, this
 strategy also allows us to avoid spilling too much memory for short
 resulting bytestrings.</p><p>Note that setting <code>firstBufSize &gt;= minBufSize</code> implies that the first buffer
 is no longer copied but allocated and filled directly. Hence, setting
 <code>firstBufSize = bufSize</code> means that all chunks will use an underlying buffer
 of size <code>bufSize</code>. This is recommended, if you know that you always output
 more than <code>minBufSize</code> bytes.</p></div></div><div class="top"><p class="src"><a name="v:toByteString" class="def">toByteString</a> :: <a href="Blaze-ByteString-Builder.html#t:Builder">Builder</a> -&gt; <a href="file:///Users/mathiashorrigan/Documents/edx/FP101x_introFunctionalProgramming/present/.cabal-sandbox/share/doc/x86_64-osx-ghc-7.8.3/bytestring-0.10.2.0/html/Data-ByteString.html#t:ByteString">ByteString</a></p><div class="doc"><p>Run the builder to construct a strict bytestring containing the sequence
 of bytes denoted by the builder. This is done by first serializing to a lazy bytestring and then packing its
 chunks to a appropriately sized strict bytestring.</p><pre>toByteString = packChunks . toLazyByteString</pre><p>Note that <code><code><a href="Blaze-ByteString-Builder.html#v:toByteString">toByteString</a></code></code> is a <code>Monoid</code> homomorphism.</p><pre>toByteString mempty          == mempty
toByteString (x `mappend` y) == toByteString x `mappend` toByteString y</pre><p>However, in the second equation, the left-hand-side is generally faster to
 execute.</p></div></div><div class="top"><p class="src"><a name="v:toByteStringIO" class="def">toByteStringIO</a> :: (<a href="file:///Users/mathiashorrigan/Documents/edx/FP101x_introFunctionalProgramming/present/.cabal-sandbox/share/doc/x86_64-osx-ghc-7.8.3/bytestring-0.10.2.0/html/Data-ByteString.html#t:ByteString">ByteString</a> -&gt; <a href="file:///usr/local/Cellar/ghc/7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/System-IO.html#t:IO">IO</a> ()) -&gt; <a href="Blaze-ByteString-Builder.html#t:Builder">Builder</a> -&gt; <a href="file:///usr/local/Cellar/ghc/7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/System-IO.html#t:IO">IO</a> ()</p><div class="doc"><p>Run the builder with a <code><a href="Blaze-ByteString-Builder-Internal.html#v:defaultBufferSize">defaultBufferSize</a></code>d buffer and execute the given
 <code><a href="file:///usr/local/Cellar/ghc/7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/System-IO.html#t:IO">IO</a></code> action whenever the buffer is full or gets flushed.</p><pre> <code><a href="Blaze-ByteString-Builder.html#v:toByteStringIO">toByteStringIO</a></code> = <code><a href="Blaze-ByteString-Builder.html#v:toByteStringIOWith">toByteStringIOWith</a></code> <code><a href="Blaze-ByteString-Builder-Internal.html#v:defaultBufferSize">defaultBufferSize</a></code></pre><p>This is a <code>Monoid</code> homomorphism in the following sense.</p><pre>toByteStringIO io mempty          == return ()
toByteStringIO io (x `mappend` y) == toByteStringIO io x &gt;&gt; toByteStringIO io y</pre></div></div><div class="top"><p class="src"><a name="v:toByteStringIOWith" class="def">toByteStringIOWith</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="file:///usr/local/Cellar/ghc/7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Int.html#t:Int">Int</a></td><td class="doc"><p>Buffer size (upper bounds
 the number of bytes forced
 per call to the <code><a href="file:///usr/local/Cellar/ghc/7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/System-IO.html#t:IO">IO</a></code> action).</p></td></tr><tr><td class="src">-&gt; (<a href="file:///Users/mathiashorrigan/Documents/edx/FP101x_introFunctionalProgramming/present/.cabal-sandbox/share/doc/x86_64-osx-ghc-7.8.3/bytestring-0.10.2.0/html/Data-ByteString.html#t:ByteString">ByteString</a> -&gt; <a href="file:///usr/local/Cellar/ghc/7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/System-IO.html#t:IO">IO</a> ())</td><td class="doc"><p><code><a href="file:///usr/local/Cellar/ghc/7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/System-IO.html#t:IO">IO</a></code> action to execute per
 full buffer, which is
 referenced by a strict
 <code><a href="file:///Users/mathiashorrigan/Documents/edx/FP101x_introFunctionalProgramming/present/.cabal-sandbox/share/doc/x86_64-osx-ghc-7.8.3/bytestring-0.10.2.0/html/Data-ByteString.html#t:ByteString">ByteString</a></code>.</p></td></tr><tr><td class="src">-&gt; <a href="Blaze-ByteString-Builder.html#t:Builder">Builder</a></td><td class="doc"><p><code><a href="Blaze-ByteString-Builder.html#t:Builder">Builder</a></code> to run.</p></td></tr><tr><td class="src">-&gt; <a href="file:///usr/local/Cellar/ghc/7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/System-IO.html#t:IO">IO</a> ()</td><td class="doc"><p>Resulting <code><a href="file:///usr/local/Cellar/ghc/7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/System-IO.html#t:IO">IO</a></code> action.</p></td></tr></table></div><div class="doc"><p><code>toByteStringIOWith bufSize io b</code> runs the builder <code>b</code> with a buffer of
 at least the size <code>bufSize</code> and executes the <code><a href="file:///usr/local/Cellar/ghc/7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/System-IO.html#t:IO">IO</a></code> action <code>io</code> whenever the
 buffer is full.</p><p>Compared to <code><a href="Blaze-ByteString-Builder.html#v:toLazyByteStringWith">toLazyByteStringWith</a></code> this function requires less allocation,
 as the output buffer is only allocated once at the start of the
 serialization and whenever something bigger than the current buffer size has
 to be copied into the buffer, which should happen very seldomly for the
 default buffer size of 32kb. Hence, the pressure on the garbage collector is
 reduced, which can be an advantage when building long sequences of bytes.</p></div></div><h1 id="g:4"><code><a href="Blaze-ByteString-Builder.html#t:Write">Write</a></code>s</h1><div class="top"><p class="src"><span class="keyword">data</span> <a name="t:Write" class="def">Write</a></p><div class="doc"><p>A write of a bounded number of bytes.</p><p>When defining a function <code>write :: a -&gt; Write</code> for some <code>a</code>, then it is
 important to ensure that the bound on the number of bytes written is
 data-independent. Formally,</p><pre> forall x y. getBound (write x) = getBound (write y)</pre><p>The idea is that this data-independent bound is specified such that the
 compiler can optimize the check, if there are enough free bytes in the buffer,
 to a single subtraction between the pointer to the next free byte and the
 pointer to the end of the buffer with this constant bound of the maximal
 number of bytes to be written.</p></div><div class="subs instances"><p id="control.i:Write" class="caption collapser" onclick="toggleSection('i:Write')">Instances</p><div id="section.i:Write" class="show"><table><tr><td class="src"><a href="file:///usr/local/Cellar/ghc/7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Monoid.html#t:Monoid">Monoid</a> <a href="Blaze-ByteString-Builder.html#t:Write">Write</a></td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><a name="v:fromWrite" class="def">fromWrite</a> :: <a href="Blaze-ByteString-Builder.html#t:Write">Write</a> -&gt; <a href="Blaze-ByteString-Builder.html#t:Builder">Builder</a></p><div class="doc"><p>Create a builder that execute a single <code><a href="Blaze-ByteString-Builder.html#t:Write">Write</a></code>.</p></div></div><div class="top"><p class="src"><a name="v:fromWriteSingleton" class="def">fromWriteSingleton</a> ::  (a -&gt; <a href="Blaze-ByteString-Builder.html#t:Write">Write</a>) -&gt; a -&gt; <a href="Blaze-ByteString-Builder.html#t:Builder">Builder</a></p></div><div class="top"><p class="src"><a name="v:fromWriteList" class="def">fromWriteList</a> ::  (a -&gt; <a href="Blaze-ByteString-Builder.html#t:Write">Write</a>) -&gt; [a] -&gt; <a href="Blaze-ByteString-Builder.html#t:Builder">Builder</a></p><div class="doc"><p>Construct a <code><a href="Blaze-ByteString-Builder.html#t:Builder">Builder</a></code> writing a list of data one element at a time.</p></div></div><div class="top"><p class="src"><a name="v:writeToByteString" class="def">writeToByteString</a> :: <a href="Blaze-ByteString-Builder.html#t:Write">Write</a> -&gt; <a href="file:///Users/mathiashorrigan/Documents/edx/FP101x_introFunctionalProgramming/present/.cabal-sandbox/share/doc/x86_64-osx-ghc-7.8.3/bytestring-0.10.2.0/html/Data-ByteString.html#t:ByteString">ByteString</a></p><div class="doc"><p>Run a <code><a href="Blaze-ByteString-Builder.html#t:Write">Write</a></code> to produce a strict <code><a href="file:///Users/mathiashorrigan/Documents/edx/FP101x_introFunctionalProgramming/present/.cabal-sandbox/share/doc/x86_64-osx-ghc-7.8.3/bytestring-0.10.2.0/html/Data-ByteString.html#t:ByteString">ByteString</a></code>.
 This is equivalent to <code>(<code><a href="Blaze-ByteString-Builder.html#v:toByteString">toByteString</a></code> . <code><a href="Blaze-ByteString-Builder.html#v:fromWrite">fromWrite</a></code>)</code>, but is more
 efficient because it uses just one appropriately-sized buffer.</p></div></div><h2 id="g:5">Writing <code>Storable</code>s</h2><div class="top"><p class="src"><a name="v:writeStorable" class="def">writeStorable</a> :: <a href="file:///usr/local/Cellar/ghc/7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Foreign-Storable.html#t:Storable">Storable</a> a =&gt; a -&gt; <a href="Blaze-ByteString-Builder.html#t:Write">Write</a></p><div class="doc"><p>Write a storable value.</p></div></div><div class="top"><p class="src"><a name="v:fromStorable" class="def">fromStorable</a> :: <a href="file:///usr/local/Cellar/ghc/7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Foreign-Storable.html#t:Storable">Storable</a> a =&gt; a -&gt; <a href="Blaze-ByteString-Builder.html#t:Builder">Builder</a></p><div class="doc"><p>A builder that serializes a storable value. No alignment is done.</p></div></div><div class="top"><p class="src"><a name="v:fromStorables" class="def">fromStorables</a> :: <a href="file:///usr/local/Cellar/ghc/7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Foreign-Storable.html#t:Storable">Storable</a> a =&gt; [a] -&gt; <a href="Blaze-ByteString-Builder.html#t:Builder">Builder</a></p><div class="doc"><p>A builder that serializes a list of storable values by writing them
 consecutively. No alignment is done. Parsing information needs to be
 provided externally.</p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.14.3</p></div></body></html>